/**
 * A service to extract Mermaid diagram code from Mermaid-generated SVGs.
 */
class SvgToMermaidService {
  /**
   * Checks if an SVG element was generated by Mermaid.
   * @param {Element} svgEl The SVG element to check.
   * @returns {boolean} True if the SVG is likely a Mermaid diagram.
   */
  isMermaidSVG(svgEl) {
    if (!(svgEl instanceof SVGSVGElement)) {
      return false;
    }
    const ariaRole = svgEl.getAttribute("aria-roledescription") || "";
    const hasFlowchartClass = svgEl.classList.contains("flowchart");
    
    const isKnownType = [
      "flowchart", "sequenceDiagram", "gantt", 
      "classDiagram", "stateDiagram", "pie"
    ].some(type => ariaRole.startsWith(type));

    return hasFlowchartClass || isKnownType;
  }

  /**
   * Converts a single Mermaid-generated SVG element to Mermaid code.
   * @param {SVGSVGElement} svgEl The SVG element to convert.
   * @returns {string|null} The Mermaid code as a string, or null if conversion is not possible.
   */
  convert(svgEl) {
    if (!this.isMermaidSVG(svgEl)) {
      return null;
    }

    const diagramType = (svgEl.getAttribute("aria-roledescription") || "flowchart").replace("-v2", "");

    switch (true) {
      case /flowchart|graph/i.test(diagramType):
        return this._extractFlowchart(svgEl, diagramType);
      default:
        console.warn(`Mermaid type "${diagramType}" is not yet supported for extraction.`);
        return `%% Mermaid diagram of type "${diagramType}" could not be parsed.`;
    }
  }

  /**
   * Creates a safe, valid identifier for Mermaid nodes and subgraphs.
   * @param {string} text The input text (e.g., from a node label or ID).
   * @returns {string} A sanitized string suitable for use as an ID.
   * @private
   */
  _createSafeMermaidId(text) {
    let safeId = text
      .replace(/[^\w\s-]/g, '')
      .trim()
      .replace(/\s+/g, '_');
    
    if (/^\d/.test(safeId)) {
      safeId = `id_${safeId}`;
    }
    
    return safeId || 'node';
  }

  /**
   * Formats a label for a Mermaid node, escaping quotes and handling newlines.
   * @param {string} htmlContent The innerHTML content from the SVG label element.
   * @returns {string} A formatted label string like ["Label text"].
   * @private
   */
  _sanitizeMermaidLabel(htmlContent) {
    // Replace <br> with a newline character for Mermaid syntax
    const textWithNewlines = htmlContent.replace(/<br\s*\/?>/gi, '\n');
    
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = textWithNewlines;
    const decodedText = tempDiv.textContent || tempDiv.innerText || '';
    
    // Escape double quotes for use inside the label string
    const escapedText = decodedText.replace(/"/g, '#quot;');
    return `["${escapedText}"]`;
  }

/**
 * Extracts flowchart/graph diagram syntax from an SVG element.
 * @param {SVGSVGElement} svgEl The SVG element containing the diagram.
 * @param {string} diagramType The type of diagram (e.g., 'graph' or 'flowchart').
 * @returns {string} The generated Mermaid code.
 * @private
 */
_extractFlowchart(svgEl, diagramType) {
  // Helper to parse "translate(x,y)" attributes
  const parseTransform = (transform) => {
    const match = /translate\(([^,]+),([^)]+)\)/.exec(transform || '');
    return match ? { x: parseFloat(match[1]), y: parseFloat(match[2]) } : { x: 0, y: 0 };
  };

  const nodes = new Map();
  const rootNodes = [];
  const edges = [];
  const clusters = [];
  const edgeLabels = [];
  const LABEL_DISTANCE_THRESHOLD = 50;

  // Pass 1: Find all clusters
  svgEl.querySelectorAll("g.cluster").forEach(clusterEl => {
    const rect = clusterEl.querySelector("rect");
    const titleEl = clusterEl.querySelector(":scope > g.cluster-label foreignObject p");
    if (!rect || !titleEl) return;
    clusters.push({
      title: titleEl.textContent.trim(),
      x: parseFloat(rect.getAttribute("x")),
      y: parseFloat(rect.getAttribute("y")),
      width: parseFloat(rect.getAttribute("width")),
      height: parseFloat(rect.getAttribute("height")),
      nodes: []
    });
  });

  // Pass 2: Find all nodes
  svgEl.querySelectorAll("g.node").forEach(nodeEl => {
    const idMatch = nodeEl.id?.match(/^flowchart-(.+?)-\d+$/);
    if (!idMatch) return;
    const originalId = idMatch[1];
    const safeId = this._createSafeMermaidId(originalId);
    const pEl = nodeEl.querySelector("foreignObject span.nodeLabel p");
    if (!pEl) return;
    const nodeText = pEl.textContent.trim();
    let openDelim = '[';
    let closeDelim = ']';
    if (nodeEl.querySelector('polygon')) {
      openDelim = '{'; closeDelim = '}';
    } else if (nodeEl.querySelector('path[d*="Q"], path[d*="C"]')) {
      openDelim = '('; closeDelim = ')';
    }
    let finalNodeText = nodeText;
    const iconEl = pEl.querySelector('i.fa');
    if (iconEl) {
      const iconClass = Array.from(iconEl.classList).find(cls => cls.startsWith('fa-') && cls !== 'fa');
      if (iconClass) {
        const iconTextContent = iconEl.textContent.trim();
        finalNodeText = `fa:${iconClass} ${nodeText.replace(iconTextContent, '').trim()}`.trim();
      }
    }
    const label = `${openDelim}"${finalNodeText}"${closeDelim}`;
    const nodeDefinition = `${safeId}${label}`;
    nodes.set(safeId, nodeDefinition); // Use the safeId as the key
    const nodePos = parseTransform(nodeEl.getAttribute("transform"));
    let assignedToCluster = false;
    for (const cluster of clusters) {
      if (nodePos.x >= cluster.x && nodePos.x <= cluster.x + cluster.width &&
          nodePos.y >= cluster.y && nodePos.y <= cluster.y + cluster.height) {
        cluster.nodes.push(nodeDefinition);
        assignedToCluster = true;
        break;
      }
    }
    if (!assignedToCluster) {
      rootNodes.push(nodeDefinition);
    }
  });

  // Pass 2.5: Gather all edge labels and their positions
  svgEl.querySelectorAll('g.edgeLabel').forEach(labelEl => {
    const textEl = labelEl.querySelector('p');
    const text = textEl ? textEl.textContent.trim() : '';
    if (text) {
      const pos = parseTransform(labelEl.getAttribute('transform'));
      edgeLabels.push({ text, ...pos, used: false });
    }
  });
  
  // --- MODIFIED: Pass 3 - New edge parsing logic for complex IDs ---
  const knownNodeIds = Array.from(nodes.keys());
  svgEl.querySelectorAll("path.flowchart-link[id^='L_']").forEach(pathEl => {
    const pathId = pathEl.id;
    const idBodyMatch = pathId.match(/^L_(.+)_\d+$/);
    if (!idBodyMatch) return;

    const idBody = idBodyMatch[1];
    let foundEdge = null;

    // Iterate through known node IDs to find a matching source ID
    for (const srcKey of knownNodeIds) {
      if (idBody.startsWith(srcKey + '_')) {
        const destKey = idBody.substring(srcKey.length + 1);
        if (knownNodeIds.includes(destKey)) {
          foundEdge = { srcId: srcKey, destId: destKey };
          break;
        }
      }
    }

    if (!foundEdge) return; // Skip if we couldn't parse the edge

    let edgeText = '';
    // Geometric label matching (remains the same)
    if (pathEl.getTotalLength && typeof pathEl.getPointAtLength === 'function' && edgeLabels.length > 0) {
      const totalLength = pathEl.getTotalLength();
      if (totalLength > 0) {
        const sampleRatios = [0.3, 0.5, 0.7];
        let bestMatch = { label: null, distance: Infinity };
        for (const ratio of sampleRatios) {
          const point = pathEl.getPointAtLength(totalLength * ratio);
          for (const label of edgeLabels) {
            if (!label.used) {
              const distance = Math.sqrt(Math.pow(point.x - label.x, 2) + Math.pow(point.y - label.y, 2));
              if (distance < bestMatch.distance) {
                bestMatch = { label, distance };
              }
            }
          }
        }
        if (bestMatch.label && bestMatch.distance < LABEL_DISTANCE_THRESHOLD) {
          edgeText = `|${bestMatch.label.text}|`;
          bestMatch.label.used = true;
        }
      }
    }
    
    const isDotted = pathEl.classList.contains('edge-pattern-dotted');
    const linkArrow = isDotted ? '-.->' : '-->';
    
    edges.push(`    ${foundEdge.srcId} ${linkArrow} ${edgeText} ${foundEdge.destId}`);
  });

  // Pass 4: Assemble the Mermaid code
  let mermaidCode = `${diagramType.toLowerCase()} TD\n`;
  rootNodes.forEach(nodeDef => {
      mermaidCode += `    ${nodeDef}\n`;
  });
  clusters.forEach(cluster => {
    if (cluster.nodes.length > 0) {
      mermaidCode += `\n    subgraph "${cluster.title}"\n`;
      cluster.nodes.forEach(nodeDef => {
          mermaidCode += `        ${nodeDef}\n`;
      });
      mermaidCode += `    end\n`;
    }
  });
  if (edges.length > 0) {
      mermaidCode += '\n' + edges.join('\n').replace(/ \s+/g, ' ');
  }
  return mermaidCode.trim();
}
}